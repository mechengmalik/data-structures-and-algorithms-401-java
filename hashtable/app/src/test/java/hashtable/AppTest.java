/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hashtable;

import org.junit.Test;

import java.util.Arrays;
import java.util.HashMap;

import static hashtable.App.repeatedWord;
import static junit.framework.TestCase.*;


public class AppTest {
    @Test public void appHasAGreeting() {


        //Adding a key/value to your hashtable results in the value being in the data structure
        Hashtable hashtable = new Hashtable(10);
        hashtable.add("s1","malik");
        assertTrue(hashtable.contains("s1"));



        //Retrieving based on a key returns the value stored
        assertEquals("malik",hashtable.get("s1"));


        //Successfully returns null for a key that does not exist in the hashtable

        assertEquals("requested key is not exist",hashtable.get("s2"));




        //Successfully handle a collision within the hashtable
        hashtable.add("a","the first");
        hashtable.add(97,"the second");

        assertEquals("the first",hashtable.nodesArray[7].value);
        assertEquals("the second",hashtable.nodesArray[7].next.value);




        //Successfully retrieve a value from a bucket within the hashtable that has a collision
        assertEquals("the first",hashtable.get("a"));



        //Successfully hash a key to an in-range value
        assertEquals(9,hashtable.hash("hi"));





    }
    //-------------------code challenge 31--------------------------


    @Test public void repeatedWordTest() {
        // testing for repeatedWord function

        String test = "Once upon a time, there was a brave princess who...";
        assertEquals("a", repeatedWord(test));

        String test2 = "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way – in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only...";
        assertEquals("it", repeatedWord(test2));

        String test3 = "It was a queer, sultry summer, the summer they electrocuted the Rosenbergs, and I didn’t know what I was doing in New York...";
        assertEquals("summer", repeatedWord(test3));



        // testing if the string doesn't have a repeated words, it should return null

        String test4 = "I wish you enjoy";

        assertNull(repeatedWord(test4));

    }

    @Test public void testHashTable3(){
        BinaryTree<Integer> tree1 = new BinaryTree<>();
        tree1.root = new TreeNode<Integer>(150);
        tree1.root.left = new TreeNode<Integer>(100);
        tree1.root.right = new TreeNode<Integer>(250);
        tree1.root.left.left = new TreeNode<Integer>(75);
        tree1.root.left.right = new TreeNode<Integer>(160);
        tree1.root.left.right.left = new TreeNode<Integer>(125);


        BinaryTree<Integer> tree2 = new BinaryTree<>();
        tree2.root = new TreeNode<Integer>(42);
        tree2.root.left = new TreeNode<Integer>(100);
        tree2.root.right = new TreeNode<Integer>(600);
        tree2.root.left.left = new TreeNode<Integer>(15);
        tree2.root.left.right = new TreeNode<Integer>(160);
        tree2.root.left.right.left = new TreeNode<Integer>(125);



        assertEquals( Arrays.asList(75, 100, 125, 160, 150, 250, 15, 100, 125, 160, 42, 600),App.treeIntersection(tree1,tree2));
    }
    @Test public void testHashMapLeftJoin(){
    HashMap<String,String> hashmap1 = new HashMap<>();
    HashMap<String,String> hashmap2 = new HashMap<>();

        hashmap1.put("fond","enamored");
        hashmap1.put("wrath","anger");
        hashmap1.put("diligent","employed");


        hashmap2.put("fond","averse");
        hashmap2.put("wrath","delight");
        hashmap2.put("diligent","idle");


    // trying the happy path

    assertEquals("[diligent: employed , idle\n" + ", wrath: anger , delight\n" + ", fond: enamored , averse\n" + "]", App.leftJoin(hashmap1,hashmap2).toString());




        hashmap1.put("outfit","garb");
        hashmap1.put("guide","usher");

        hashmap2.put("guide","follow");
        hashmap2.put("flow","jam");


    // some data in the first is not in the second and the opposite

    assertEquals("[diligent: employed , idle\n" +
                         ", outfit: garb , Null\n" +
                         ", wrath: anger , delight\n" +
                         ", guide: usher , follow\n" +
                         ", fond: enamored , averse\n" +
                         "]", App.leftJoin(hashmap1,hashmap2).toString());

    }

}
