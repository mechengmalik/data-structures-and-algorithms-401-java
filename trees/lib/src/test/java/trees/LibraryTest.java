/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.checkerframework.checker.units.qual.K;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class LibraryTest {
  @Test void testBinaryTree(){
      //Can successfully instantiate an empty tree
      BinaryTree<Integer> binaryTree = new BinarySearchTree<>();
      assertNull(binaryTree.root);
        //Can successfully instantiate a tree with a single root node
      BinaryTree<Integer> binaryTree1 = new BinarySearchTree<>(10);
      assertEquals(10,binaryTree1.root.value);

      //Can successfully add a left child and right child to a single root node
      binaryTree1.root.leftRoot = new Node<>(5);
      binaryTree1.root.rightRoot = new Node<>(15);
      assertEquals(5, binaryTree1.root.leftRoot.value);
      assertEquals(15,binaryTree1.root.rightRoot.value);

//Can successfully return a collection from a preorder traversal
      assertEquals("[10, 5, 15]",binaryTree1.preOrder(binaryTree1.root).toString());

      //Can successfully return a collection from an inorder traversal
      assertEquals("[5, 10, 15]",binaryTree1.inOrder(binaryTree1.root).toString());

        //Can successfully return a collection from a postorder traversal
      assertEquals("[5, 15, 10]",binaryTree1.postOrder(binaryTree1.root).toString());

//      ------------------CC 16--------------------
      // can get the max correctly

      assertEquals(15,binaryTree1.Max() );




      //------------------CC 17--------------------//
      //check for a normal binary tree returns
      assertEquals("[10, 5, 15]",Library.breadthFirst(binaryTree1).toString());


      //------------------CC 18--------------------//
//      If the value is divisible by 3, replace the value with “Fizz”
//      If the value is divisible by 5, replace the value with “Buzz”
//      If the value is divisible by 3 and 5, replace the value with “FizzBuzz”
//      If the value is not divisible by 3 or 5, simply turn the number into a String.
      KaryTree<Integer> kTree = new KaryTree<>(3);
      kTree.add(5);
      kTree.add(10);
      kTree.add(15);
      kTree.add(3);
      kTree.add(30);
      kTree.add(8);
      kTree.add(9);
      kTree.add(1);

      KaryTree<String> fizzBuzz = KaryTree.fizzBuzzTree(kTree);
      List<String> fizBuzList = fizzBuzz.breadthFirstSearch();
      System.out.println(fizzBuzz.breadthFirstSearch());
      assertArrayEquals(Arrays.asList("Buzzz", "Buzzz", "FizzBuzzz", "Fizzz", "FizzBuzzz", "8", "Fizzz", "1").toArray(),fizBuzList.toArray());







////      If the value is divisible by 5, replace the value with Buzz
//      assertEquals("Buzzz",fizzbuzz.root.value);
//
////      If the value is divisible by 3, replace the value with Fizz
//        assertEquals("Fizzz",);
//
////      If the value is divisible by 3 and 5, replace the value with FizzBuzz
//      assertEquals("FizzBuzz",fizzbuzz.root.allChildren.get(1).value);



  }


}
